/*
   Copyright (C) 2020 MouveApp

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */
package com.ravindrabarthwal.fstring

import android.content.Context
import android.content.SharedPreferences
import android.content.res.Resources
import android.util.Log
import androidx.annotation.StringRes
import com.ravindrabarthwal.fstring.FString.update
import org.json.JSONArray
import org.json.JSONObject
import java.lang.reflect.Field

/**
 * FString provides an elegant solution for dynamic string resources. It enables use of
 * [StringRes] and [update] the StringRes dynamically without changing the xml values manually.
 *
 * The common use case is using FString and updating values from the server for strings without manually
 * shipping a new app release. You can also combine FString to update values from Firebase Remote Config
 * giving much more flexibility and power to do A/B testing on Strings without any major changes in code.
 *
 * Uses [SharedPreferences] to store and get the value for a string. Returns default value from [StringRes]
 * if preference key not found.
 *
 * Some common vocab that you will see in code.
 * 1. resId: [Int] The generated Id for a [StringRes] generated by [Resources]
 * 2. resKey: [String] The name by which a string is saved in strings.xml.
 * Eg. R.string.my_string then `my_string` is resKey
 * 3. resValue: [String] The value for a resKey
 *
 *
 * @author Ravindra Barthwal - https://github.com/ravindrabarthwal
 * @author Palash Bansal - https://github.com/palashbansal96
 * This amazing piece of code was born at https://mouve.app and still powers Mouve App
 */
object FString {
    /**
     * TAG to [Log]
     */
    private const val TAG = "FString"

    /**
     * Preference file name where all the data will be stored.
     */
    private const val PREF_NAME = "fstring_config"

    /**
     * The prefix key which will be used to save a resValue for a given resKey in the SharedPreference
     */
    private const val PREF_PREFIX_KEY = "fstring"

    /**
     * Lambda that returns [SharedPreferences]
     */
    private val getPref: (Context) -> SharedPreferences = { context ->
        context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE)
    }

    /**
     * The resource string class which will be used to get [StringRes] field using reflection.
     */
    private var resourceStringClass: Class<*>? = null

    /**
     * This field holds the [Map] of resId and resKey. For definition of resId and resKey see [FString] class doc
     */
    private var resourceStringMap: Map<Int, String>? = null

    /**
     * Initializes the FString to be ready. Must initialize before any getString call else will return empty string.
     * @param stringResourceClass - java class must be [Resources].[String]
     *
     * In your Android Application
     * ```
     *      // Import the Resource String class (In the import section)
     *      import com.example.app.R.string as RString
     *
     *      // In onCreate
     *      super.onCreate()
     *      FString.init(RString::class.java) (Kotlin)
     * ```
     */
    fun init(stringResourceClass: Class<*>) {
        resourceStringClass = stringResourceClass
    }

    /**
     *  Returns [String] from [resId]. Returns the value from the preference or default
     *
     *  @param context [Context]
     *  @param resId [StringRes]
     *
     *  @return [String]
     */
    fun getString(context: Context, @StringRes resId: Int): String {
        val defaultValue = getDefaultStringFromResId(context, resId)
        val pref = getPref(context)
        val key = makePrefKeyFromResId(context, resId)
        return pref.getString(key, defaultValue)!!
    }

    /**
     * Returns a map of resId and resKey. Returns empty map if [resourceStringClass] and [resourceStringClass]
     * both are null else populates the [resourceStringMap] from [resourceStringClass] using reflection and
     * returns [resourceStringMap]
     *
     * @param context [Context]
     *
     * @return [Map]<[Int], [String]> Map of resId and resKey
     */
    private fun getResIdStringMap(context: Context): Map<Int, String> {
        if (resourceStringMap == null && resourceStringClass == null) return mapOf()

        if (resourceStringMap == null) {
            resourceStringMap = mapOf(*(resourceStringClass!!.fields.map { field: Field ->
                Pair(getStringResIdFromKey(context, field.name), field.name)
            }.toTypedArray()))
        }
        return resourceStringMap!!
    }

    /**
     * Returns the default value for a [StringRes] from [Resources] using [Context.getString] else empty string.
     *
     * @param context [Context]
     * @param resId [Int] For definition check [FString] class doc
     *
     * @return [String]
     */
    private fun getDefaultStringFromResId(context: Context, resId: Int): String = try {
        context.getString(resId)
    } catch (e: Resources.NotFoundException) {
        Log.w(TAG, "Unable to find resId $resId default value", e)
        ""
    }

    /**
     * Returns the preference key from a [resId]
     *
     * @param context [Context]
     * @param resId [Int] For definition check [FString] class doc
     *
     * @return [String] preference key for a resId
     */
    private fun makePrefKeyFromResId(context: Context, resId: Int): String {
        val resKey = getKeyFromStringResId(context, resId)
        return makeFinalPrefKey(resKey)
    }

    /**
     * Makes the final preference key from the [resKey].
     *
     * @param resKey For definition check [FString] class doc
     *
     * @return [String] [resKey] with [PREF_PREFIX_KEY]
     */
    private fun makeFinalPrefKey(resKey: String): String = PREF_PREFIX_KEY + "_" + resKey

    /**
     * Returns the resId for a resKey
     *
     * @param context [Context]
     * @param resKey For definition check [FString] class doc
     *
     * @return [Int] resId
     */
    private fun getStringResIdFromKey(context: Context, resKey: String): Int =
        context.resources.getIdentifier(resKey, "string", context.packageName)

    /**
     * Returns the resKey for a resId
     *
     * @param context [Context]
     * @param resId For definition check [FString] class doc
     *
     * @return [String] resKey
     */
    private fun getKeyFromStringResId(context: Context, resId: Int): String =
        getResIdStringMap(context).getOrElse(resId, defaultValue = { "" })


    /**
     * Updates the [FString]'s [SharedPreferences] from the [json]. The json must be parsable to [JSONObject]
     *
     * @param context [Context]
     * @param json [String] that can be parsed as [JSONObject]
     */
    fun update(context: Context, json: String) {
        if (json.isNotEmpty()) {
            try {
                val jsonObj = JSONObject(json)
                setFromJSON(context, jsonObj)
            } catch (e: Exception) {
                Log.e(TAG, "Updating FString failed.", e)
            }
        }
    }

    /**
     * The helper function that takes a [JSONObject] and iterates over the keys and save
     * in the [SharedPreferences]
     *
     * @param context [Context]
     * @param [json] [JSONObject] with key value pair of resKey and corresponding [String value]
     */
    private fun setFromJSON(context: Context, json: JSONObject) {
        val map = getResIdStringMap(context)
        val prefEdit = getPref(context).edit()
        for (jsonKey in json.keys()) {
            map.values.find { it == jsonKey }?.let { resKey ->
                try {
                    val value = json.getString(resKey)
                    val prefKey = makeFinalPrefKey(resKey)
                    prefEdit.putString(prefKey, value)
                } catch (e: Exception) {
                    Log.e(TAG, "setFromJSON error while adding $resKey to preferences.", e)
                }
            }
        }
        prefEdit.apply()
    }

    /**
     * Clear all values from the [FString]'s [SharedPreferences]
     *
     * @param context [Context]
     */
    fun clearAll(context: Context) {
        getPref(context).edit().clear().apply()
    }

    /**
     * Clears the data for the keys stored in [FString]'s [SharedPreferences] using [json].
     * The json must be parsable to [JSONArray] containing the keys to be removed.
     *
     * @param context [Context]
     * @param json [String] Must be parsable to [JSONArray]
     */
    fun clear(context: Context, json: String) {
        val prefEdit = getPref(context).edit()
        if (json.isNotEmpty()) {
            try {
                val jsonArray = JSONArray(json)
                for (i in 0 until jsonArray.length()) {
                    prefEdit.remove(makeFinalPrefKey(jsonArray[i].toString()))
                }
            } catch (e: Exception) {
                Log.e(
                    TAG,
                    "Clearing FString using json failed.",
                    e
                )
            } finally {
                prefEdit.apply()
            }
        }
    }
}

/**
 * Extension function to get FString similar to getString
 * @param resId [StringRes]
 *
 * @return [String]
 */
fun Context.getFString(@StringRes resId: Int): String {
    return FString.getString(this, resId)
}
